<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<script src='vendor/three.js/build/three.min.js'></script>
<script src='vendor/three.js/examples/js/controls/OrbitControls.js'></script>
<div style='position: absolute; top: 0px; width: 100%;font-family:arial; font-weight: bolder; padding-top: 5px;'>
	<!-- <a href="https://github.com/jeromeetienne/threejsboilerplate" target="_blank">Boilerplate</a>
	for
	<a href="http://threejs.org" target="_blank">three.js</a>
	- works on desktop and mobile -->
</div><body style='margin: 0px; overflow: hidden; text-align:center;'><script>
	//////////////////////////////////////////////////////////////////////////////////
	//		Init
	//////////////////////////////////////////////////////////////////////////////////

	var wind = 1;
	var fire = 1;
	var water = 1;

	// init renderer
	var renderer	= new THREE.WebGLRenderer({
		antialias	: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 1)
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	// array of functions for the rendering loop
	var onRenderFcts= [];

	// init scene and camera
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
	camera.position.z = 2;
	var controls	= new THREE.OrbitControls(camera)

	//////////////////////////////////////////////////////////////////////////////////
	//		add an object in the scene
	//////////////////////////////////////////////////////////////////////////////////

	// add a torus	
	// var geometry	= new THREE.TorusKnotGeometry(0.5-0.12, 0.12);
	// var material	= new THREE.MeshNormalMaterial(); 
	// var mesh	= new THREE.Mesh( geometry, material );
	// scene.add( mesh );

	var geometry = new THREE.BoxGeometry(50,50,0,1);
	// var meterial = new THREE.MeshBasicMaterial( { color: "red" } );
	// var materialArray = [];
	// for(var i = 0; i < 6; i ++){
	// 	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/ciel.png' ) }));
	// }
	// var material = new THREE.MeshFaceMaterial(materialArray);

	var material = new THREE.MeshBasicMaterial( { 
	    color: "#8cf4f4", 
	    shading: THREE.FlatShading,
	    vertexColors: THREE.VertexColors,
	    transparent: true 
	});

	var ciel = new THREE.Mesh(geometry, material);
	ciel.position.y = 1;
	ciel.position.z = -20;

	scene.add(ciel);



	var geometry = new THREE.BoxGeometry(50,50,0,1);;

	var material = new THREE.MeshBasicMaterial( { 
	    color: "#D34917", 
	    shading: THREE.FlatShading,
	    vertexColors: THREE.VertexColors,
	    transparent: true
	});

	var ciel2 = new THREE.Mesh(geometry, material);
	ciel2.position.y = 1;
	ciel2.position.z = -21;
	scene.add(ciel2);

	var geometry = new THREE.BoxGeometry(5,5,0,1);
	// var meterial = new THREE.MeshBasicMaterial( { color: "red" } );
	var materialArray = [];
	for(var i = 0; i < 6; i ++){
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/pissenlit_petales.png'), transparent: true }));
	}
	var material = new THREE.MeshFaceMaterial(materialArray);
	var soleil = new THREE.Mesh(geometry, material);
	soleil.position.x = 1;
	soleil.position.z = -15;

	scene.add(soleil);

	var geometry = new THREE.BoxGeometry(11.5,6.6,0,1);
	// var meterial = new THREE.MeshBasicMaterial( { color: "red" } );
	var materialArray = [];
	for(var i = 0; i < 6; i ++){
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/colines.png' ), transparent: true }));
	}
	var material = new THREE.MeshFaceMaterial(materialArray);
	var colines = new THREE.Mesh(geometry, material);
	colines.position.y = 0.2;
	colines.position.z = -5;

	scene.add(colines);


	addMoulins();
	addFleurs();

	// camera.position.z = 10;

	function addMoulins(){
		moulins = [];
		moulins.push(addMoulin(0.3, 0.65, 0, -1, -0.2, -1.4));
		moulins.push(addMoulin(0.3, 0.65, 0, -2, -0.4, -1.4));
		moulins.push(addMoulin(0.3, 0.65, 0, 2, -0.1, -2.5));
	}

	function addMoulin(w, h, d, x, y, z){
		var moulin = {};

		var geometry = new THREE.BoxGeometry(w,h,d,1);
		// var meterial = new THREE.MeshBasicMaterial( { color: "red" } );
		var materialArray = [];
		for(var i = 0; i < 6; i ++){
			materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/moulin_base.png' ), transparent: true }));
		}
		var material = new THREE.MeshFaceMaterial(materialArray);
		var moulin_base = new THREE.Mesh(geometry, material);
		moulin_base.position.x = x;
		moulin_base.position.y = y;
		moulin_base.position.z = z;

		moulin.base = moulin_base;
		scene.add(moulin_base);

		var geometry = new THREE.BoxGeometry(h,h,d,1);
		// var meterial = new THREE.MeshBasicMaterial( { color: "red" } );
		var materialArray = [];
		for(var i = 0; i < 6; i ++){
			materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/moulin_helice.png' ), transparent: true }));
		}
		var material = new THREE.MeshFaceMaterial(materialArray);
		moulin_helice = new THREE.Mesh(geometry, material);
		moulin_helice.position.x = x + 0.02;
		moulin_helice.position.y = y + 0.35;
		moulin_helice.position.z = z + 0.01;
		moulin_helice.name = "moulin_helice";

		moulin.helice = moulin_helice;
		scene.add(moulin_helice);

		return moulin;
	}

	function addFleurs(){
		fleurs = [];
		//x, y, z
		for(var i = 0; i <Â 50; i++){
			var randX = randomBetween(-2, 2);
			var randY = randomBetween(-0.3, -0.8) - 0.2;
			var randZ = randomBetween(-1.18, -1.22) * randY * 10 - 10;
			fleurs.push(addFleur(randX, randY, randZ));
		}
		// fleurs.push(addFleur(1, -0.5, -0.2));
		// fleurs.push(addFleur(0, -0.52, -0.2));
		// fleurs.push(addFleur(0.2, -0.54, -0.21));
		// fleurs.push(addFleur(0.4, -0.56, -0.21));
	}

	function randomBetween(start, stop){
		return (start + (Math.random()* (stop - start) ));
	}

	function addFleur(x, y, z){
		var fleur = {};
		var w = 0.8/8;
		var h = 0.8/8;
		var d = 0;

		var geometry = new THREE.BoxGeometry(w,h,d,1);
		// var meterial = new THREE.MeshBasicMaterial( { color: "red" } );
		var materialArray = [];
		for(var i = 0; i < 6; i ++){
			materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/pissenlit_petales.png' ), transparent: true }));
		}
		var material = new THREE.MeshFaceMaterial(materialArray);
		var petales = new THREE.Mesh(geometry, material);
		petales.position.x = x;
		petales.position.y = y;
		petales.position.z = z;

		fleur.petales = petales;
		scene.add(petales);

		var geometry = new THREE.BoxGeometry(w/10,w,d,1);
		// var meterial = new THREE.MeshBasicMaterial( { color: "red" } );
		var materialArray = [];
		for(var i = 0; i < 6; i ++){
			materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/tige.png' ), transparent: true }));
		}
		var material = new THREE.MeshFaceMaterial(materialArray);
		tige = new THREE.Mesh(geometry, material);
		tige.position.x = x + 0.02 * w;
		tige.position.y = y - 0.55 * w;
		tige.position.z = z - 0.01 * w;
		tige.position.origX = tige.position.x; 
		tige.name = "tige";
		// tige.applyMatrix(new THREE.Matrix4().makeTranslation( (w/10) / 2,0,0,0));


		fleur.tige = tige;
		scene.add(tige);

		return fleur;
	}

	//////////////////////////////////////////////////////////////////////////////////
	//		render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////

	// handle window resize
	window.addEventListener('resize', function(){
		renderer.setSize( window.innerWidth, window.innerHeight )
		camera.aspect	= window.innerWidth / window.innerHeight
		camera.updateProjectionMatrix()		
	}, false)

	// render the scene
	onRenderFcts.push(function(){
		renderer.render( scene, camera );		
	})
	
	// run the rendering loop
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		
		//

		for (var i = 0; i < moulins.length; i++){
			moulins[i].helice.rotateZ(-0.001 * wind);
		}

		for (var i = 0; i < fleurs.length; i++){
			//min -0.8 max 0.8
			var randd = 0;
			if(wind > 50){
				randd = Math.random() * mapIt(wind,0,100,-0.01,0.01);
			}
			fleurs[i].tige.position.x = fleurs[i].tige.position.origX - mapIt(wind,0,100,-0.1,0.1) + randd;
			fleurs[i].petales.rotation.z = mapIt(wind,0,100,-0.6,0.6) + randd;
			fleurs[i].petales.position.x = fleurs[i].tige.position.origX - mapIt(wind,0,100,-0.12,0.12) + randd;
			fleurs[i].tige.rotation.z = mapIt(wind,0,100,-0.8,0.8) + randd;
		}

		soleil.position.y = mapIt(fire, 0, 100, -2, 4);

		ciel.material.opacity = mapIt(fire, 0, 100, 1, 0);

		//
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})

	function mapIt(value, min, max, newMin, newMax){
		if(value < min){
			value = min;
		}
		else if (value > max){
			value = max;
		}
		var mapped = (value - min) / (max - min) * (newMax - newMin) + newMin;
		// console.log(mapped);
		return mapped;
	}

</script>
<script src="/socket.io/socket.io.js"></script><script>
	//-----------
	//
	//	SOCKET CONNECTION
	//
	//

	var socket = io();
	socket.on("init", function(initValues){
		// console.table(initValues);
		wind = initValues["wind"] || wind;
		fire = initValues["fire"] || fire;
		water = initValues["water"] || water;
	});

	socket.on("event", function(e){
		if(e.type == "wind"){
			wind = e.value;
			// console.warn("Spin speed : " + wind);
		}else if(e.type == "fire"){
			fire = e.value;
			// console.warn("Fire temperature : " + fire);
		}
		else if(e.type == "water"){
			water = e.value;
			// console.warn("Water flow : " + water);
		}
		// console.log("event: " + e);
	});
</script>
</body>
